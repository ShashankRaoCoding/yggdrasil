{"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":" \n\t \n\t\twindow.location.href = `shashankraocoding.github.io/yggdrasil/yggdrasil` \n\t \n \n \n\t \n\t\t.page-title { \n\t\t\tfont-size: 1.70rem; \n\t\t}\n\t \n"},"yggdrasil/Chemoproteogenomics":{"slug":"yggdrasil/Chemoproteogenomics","filePath":"yggdrasil/Chemoproteogenomics.md","title":"Chemoproteogenomics","links":["genomics"],"tags":[],"content":"Chemoproteogenomics is an interdisciplinary field that combines chemoproteomics and genomics to gain a deeper and more comprehensive understanding of biological systems, particularly in the context of disease like cancer.1\nHere‚Äôs a breakdown of what that means:\n\n\ngenomics: This involves studying the entire set of an organism‚Äôs genes (its genome), including genetic variations like mutations.2 In the context of chemoproteogenomics, this often involves analyzing whole exome sequencing (WES) and RNA sequencing (RNA-seq) data to identify genetic alterations.3\n\n\nChemoproteomics: This is a powerful chemical biology technique that uses small molecule probes to identify and characterize protein-small molecule interactions on a global, proteome-wide scale. It‚Äôs particularly useful for:\n\n\nIdentifying functional amino acids: For instance, it can pinpoint specific cysteine residues that are highly reactive or susceptible to modification, which often indicates their importance for protein function.4\n\n\nAssessing druggability: It can help determine which proteins or specific sites on proteins are ‚Äúdruggable‚Äù ‚Äì meaning they can be targeted by small molecule therapies.5\n\n\nUnderstanding drug mechanisms: By identifying what proteins a drug interacts with, it can shed light on how the drug works and any potential off-target effects.6\n\n\n\n\nHow Chemoproteogenomics Integrates Them:\nThe ‚Äúgenomics‚Äù part informs the ‚Äúchemoproteomics‚Äù part. For example, in cancer, genetic mutations can lead to altered proteins, including those with new or modified cysteine residues.7 These ‚Äúgain-of-cysteine‚Äù mutations are particularly interesting because cysteine residues are often targets for chemical probes and drugs.8\nChemoproteogenomics platforms aim to:\n\n\nIdentify genetic variants: By analyzing genomic data, researchers can pinpoint mutations that lead to changes in protein sequences, such as the acquisition of new cysteines.9\n\n\nMap the functional landscape of these variants: Using chemoproteomics, they can then assess the reactivity, druggability, and functional significance of these altered or newly acquired protein sites.10 This helps understand how genetic variations translate into changes at the protein level and how these changes might impact disease or drug response.11\n\n\nGuide therapeutic discovery: By linking genetic information to protein function and druggability, chemoproteogenomics can accelerate the development of precision therapies that specifically target the unique molecular characteristics of a disease.12\n\n\nIn essence, chemoproteogenomics helps bridge the gap between genetic understanding of disease and the functional consequences at the protein level, ultimately guiding the discovery of new therapeutic strategies.13"},"yggdrasil/Download-PLINK-2":{"slug":"yggdrasil/Download-PLINK-2","filePath":"yggdrasil/Download PLINK 2.md","title":"Download PLINK 2","links":[],"tags":[],"content":"Download Plink2\nmkdir -p ~/bin &amp;&amp; source ~/.profile\nwget -P ~/bin/ s3.amazonaws.com/plink2-assets/plink2_linux_x86_64_latest.zip\nunzip ~/bin/plink2_linux_x86_64_latest.zip -d ~/bin/\nrm -v ~/bin/plink2_linux_x86_64_latest.zip\nplink2 --version\n"},"yggdrasil/MAVE-Assays":{"slug":"yggdrasil/MAVE-Assays","filePath":"yggdrasil/MAVE Assays.md","title":"MAVE Assays","links":[],"tags":[],"content":"MAVE assays ‚Äî short for Multiplexed Assays for Variant Effect ‚Äî are experimental techniques used to measure the functional impact of many genetic variants at once. Instead of testing one mutation at a time, MAVE lets researchers test thousands (or more) of variants simultaneously in a high-throughput way.\nüî¨ What does a MAVE assay do?\nIt assesses how each possible mutation (or variant) in a target gene or protein affects its function, expression, or interaction. This helps in:\n\n\nUnderstanding which mutations are damaging or benign\n\n\nPredicting disease risk\n\n\nCreating better functional annotations for genes\n\n\n\nüß™ How does it work (simplified)?\n\n\nMutant Library: You create a large library of gene variants (e.g., all possible single-nucleotide changes).\n\n\nIntroduce into Cells: You introduce these into cells or organisms in a pooled format.\n\n\nFunctional Selection or Screening: You apply a selection pressure or perform a functional assay that lets you distinguish variants (e.g., by growth, binding ability, fluorescence).\n\n\nSequencing: You use next-generation sequencing to see which variants enriched or depleted under the condition.\n\n\nScoring: You calculate a functional score for each variant ‚Äî showing how ‚Äúgood‚Äù or ‚Äúbad‚Äù it is compared to the wild-type.\n\n\n\nüß† Why are MAVE assays powerful?\nThey allow:\n\n\nSystematic mapping of genotype‚Äìphenotype relationships\n\n\nStudy of variants of unknown significance (VUS) in clinical genetics\n\n\nTesting drug effects on mutant proteins\n\n\nBenchmarking and improving computational variant effect predictors\n\n\n\nüîÅ Example Techniques\nSome common forms of MAVE assays:\n\n\nDeep Mutational Scanning (DMS): Often used on proteins\n\n\nSaturation Genome Editing (SGE): Used to test all variants at a locus using CRISPR\n\n\nMassively Parallel Reporter Assays (MPRA): Used to test variants in regulatory DNA\n\n\n"},"yggdrasil/PLINK-(Complete)":{"slug":"yggdrasil/PLINK-(Complete)","filePath":"yggdrasil/PLINK (Complete).md","title":"PLINK (Complete)","links":["yggdrasil/Download-PLINK-2","tags/coding","tags/bash","tags/biology"],"tags":["coding","bash","biology"],"content":"For some useful PLINK Code, see Download PLINK 2\nPLINK is a popular open-source genetic data analysis tool primarily used in genome-wide association studies (GWAS) and population genetics. It‚Äôs super efficient for handling large-scale genotype data, especially in .ped/.map or .bed/.bim/.fam formats.\nüîπ What it does:\n\nData filtering (e.g., MAF, HWE, missingness)\nAssociation testing (case/control, quantitative traits)\nLD pruning and clumping\nIBD/IBS analysis\nPCA for population structure\nFile format conversion (e.g., VCF ‚Üí PLINK)\n\nüîπ Common PLINK commands:\nplink --bfile data --assoc         # Basic association test\nplink --bfile data --make-bed      # Convert to binary PLINK format\nplink --bfile data --pca           # Principal component analysis\nüîπ Why people love it:\n\nIt‚Äôs lightweight and fast\nEasy to script in pipelines\nPlays well with R, Python, and other tools like REGENIE, BOLT-LMM, and PRSice\n\nIf you‚Äôre starting with GWAS or QC, PLINK is pretty much your go-to tool.\ncoding bash biology"},"yggdrasil/Pandas-(Complete)":{"slug":"yggdrasil/Pandas-(Complete)","filePath":"yggdrasil/Pandas (Complete).md","title":"Pandas (Complete)","links":["yggdrasil/Pandas-Cheat-Sheet-(General-Use)"],"tags":[],"content":"For quick syntax help, see Pandas Cheat Sheet (General Use)"},"yggdrasil/Pandas-Cheat-Sheet-(General-Use)":{"slug":"yggdrasil/Pandas-Cheat-Sheet-(General-Use)","filePath":"yggdrasil/Pandas Cheat Sheet (General Use).md","title":"Pandas Cheat Sheet (General Use)","links":[],"tags":[],"content":"1. Importing and Creating DataFrames\nimport pandas as pd\n \n# From CSV / Excel\ndf = pd.read_csv(&#039;file.csv&#039;)\ndf = pd.read_excel(&#039;file.xlsx&#039;)\n \n# From dictionary\ndf = pd.DataFrame({&#039;name&#039;: [&#039;Alice&#039;, &#039;Bob&#039;], &#039;age&#039;: [25, 30]})\n\n2. Inspecting Data\ndf.head()         # First 5 rows\ndf.tail()         # Last 5 rows\ndf.info()         # Summary of columns, non-nulls\ndf.describe()     # Stats for numeric cols\ndf.shape          # (rows, columns)\ndf.columns        # Column names\ndf.dtypes         # Data types\n\n3. Selecting Data\ndf[&#039;col&#039;]                     # One column\ndf[[&#039;col1&#039;, &#039;col2&#039;]]          # Multiple columns\ndf.iloc[0]                    # First row (by position)\ndf.loc[0]                     # First row (by index)\ndf.loc[0, &#039;col&#039;]              # Cell by label\ndf.iloc[0, 1]                 # Cell by position\n \ndf[df[&#039;age&#039;] &gt; 25]            # Conditional selection\n\n4. Modifying Data\ndf[&#039;new&#039;] = df[&#039;age&#039;] + 1     # New column\ndf.rename(columns={&#039;old&#039;: &#039;new&#039;})    # Rename column\ndf.drop(&#039;col&#039;, axis=1)        # Drop column\ndf.drop(0, axis=0)            # Drop row by index\n \n# Note: use | and &amp; \n\n5. Mapping &amp; Applying\ndf[&#039;col&#039;].map(lambda x: x*2)             # Element-wise map (you can also use a dictionary) \ndf[&#039;col&#039;].apply(custom_func)            # Custom function\ndf.apply(func, axis=1)                  # Row-wise\ndf.applymap(str.upper)                  # Whole DataFrame\n\n6. Cleaning Data\ndf.dropna()                  # Drop rows with NaN\ndf.fillna(0)                 # Fill NaNs\ndf[&#039;col&#039;].str.strip()        # Remove whitespace\ndf[&#039;col&#039;].astype(int)        # Convert type\ndf.duplicated().sum()        # Count duplicates\ndf.drop_duplicates()         # Remove duplicates\n\n7. Grouping &amp; Aggregating\ndf.groupby(&#039;col&#039;).mean()\ndf.groupby(&#039;col&#039;)[&#039;val&#039;].sum()\ndf.pivot_table(index=&#039;A&#039;, columns=&#039;B&#039;, values=&#039;C&#039;, aggfunc=&#039;sum&#039;)\n\n8. Merging &amp; Joining\npd.concat([df1, df2])                       # Stack vertically\npd.merge(df1, df2, on=&#039;key&#039;)               # SQL-style join\npd.merge(df1, df2, how=&#039;left&#039;, on=&#039;key&#039;)   # Left join\n\n9. Exporting\ndf.to_csv(&#039;output.csv&#039;, index=False)\ndf.to_excel(&#039;output.xlsx&#039;)\n\n10. Useful Tricks\ndf[&#039;col&#039;].value_counts()      # Count unique values\ndf.sort_values(by=&#039;col&#039;)      # Sort by column\ndf.sample(n=5)                # Random sample\ndf.reset_index(drop=True)     # Reset index\n11. Group Data\ngrouped = data.groupby(&quot;GroupColumn&quot;)\n‚ÄúSplit data per unique value in GroupColumn.‚Äù\n‚úÖ Example:\nSay your data looks like this:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGroupColumnNumericalColumnA3A5B2B4A7\nWould output:\nA\n  GroupColumn  NumericalColumn\n0           A                3\n1           A                5\n4           A                7\n\nB\n  GroupColumn  NumericalColumn\n2           B                2\n3           B                4\n\nThe above output is produced by the code:\nfor group, group_data in data.groupby(&quot;GroupColumn&quot;):\n    print(group)\n    print(group_data)"},"yggdrasil/Piping-File-Contents-to-Ollama3":{"slug":"yggdrasil/Piping-File-Contents-to-Ollama3","filePath":"yggdrasil/Piping File Contents to Ollama3.md","title":"Piping File Contents to Ollama3","links":[],"tags":[],"content":"Use this code to pipe a file‚Äôs contents directly to llama3:\nGet-Content &quot;filepath&quot; | ollama run llama3 &quot;prompt&quot; \n "},"yggdrasil/Python-DataSci-Libs":{"slug":"yggdrasil/Python-DataSci-Libs","filePath":"yggdrasil/Python DataSci Libs.md","title":"Python DataSci Libs","links":["yggdrasil/Pandas-(Complete)","yggdrasil/Sea-Born's-Data-Visualisation-Code","Matplotlib"],"tags":[],"content":"You should be familiar with:\n\n Pandas (Complete) (tables)\n Sea Born‚Äôs Data Visualisation Code (visualisation)\n Matplotlib (visualisation)\n"},"yggdrasil/Python-to-work-with-GZIP":{"slug":"yggdrasil/Python-to-work-with-GZIP","filePath":"yggdrasil/Python to work with GZIP.md","title":"Python to work with GZIP","links":[],"tags":[],"content":"Useful python to read and write to and from a gzip\nimport gzip\n \n# Writing as text\nwith gzip.open(&#039;output.txt.gz&#039;, &#039;wt&#039;) as f:  # &#039;wt&#039; = write text\n    f.write(&quot;Hello, GZIP!\\nThis is a test.&quot;)\n \n# Writing as binary\nwith gzip.open(&#039;output.txt.gz&#039;, &#039;wb&#039;) as f:\n    f.write(b&quot;Binary data here\\nAnother line&quot;)\n \nimport gzip\n \n# Reading as text (e.g., CSV, JSON, etc.)\nwith gzip.open(&#039;file.txt.gz&#039;, &#039;rt&#039;) as f:  # &#039;rt&#039; = read text\n    for line in f:\n        print(line.strip())\n \n# Reading as binary\nwith gzip.open(&#039;file.txt.gz&#039;, &#039;rb&#039;) as f:\n "},"yggdrasil/REGENIE-(Complete)":{"slug":"yggdrasil/REGENIE-(Complete)","filePath":"yggdrasil/REGENIE (Complete).md","title":"REGENIE (Complete)","links":["yggdrasil/polygenic-risk-score"],"tags":[],"content":"What it is\nEssentially, it is a tool that allows you to test GWAS signals/genetic instrument associations while accounting for ancestry.\nSome users have reported issues like inflated p‚Äëvalues under certain settings‚Äîthough these often require careful QC and parameter tuning to resolve opensourcebiology.eu.sa\nHow it works\nImagine some dummy data for an organism that has 4 genes\nIndividual A has a trait and mutant genetic variants of genes 2, 3, and 4.\nIndividual B has the same trait and the same genetic variants on genes 3 and 4.\nThere are other individuals also, such that they model the data below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGenotypeTrait123412340.81340.9120.110.2This could lead us to believe that the genetic variants on genes 3 and 4 are responsible for the trait, but in reality the trait on gene 4 is a covariate because A and B are related.\nIf we just did a simple association test for gene 4 now, we would be lead to think that gene 4 is causally related to the trait. The issue is that we don‚Äôt have a data point for genotype 1, 2, 3. We also don‚Äôt have a datapoint with just genotype 4.\nNote, even if we did have these, that would not solve the true problem, as in reality we likely have 100s of genes that each contribute a little, and thus we have small values for all of them. However, for the purposes of this example, let‚Äôs continue with 4 genes.\nBut we can use the statistics from rest of the population to essentially predict how a person with genotype 1, 2, 3 would show the trait. This is the polygenic risk score prediction.\nTo do this, we first calculate the risk of 1, 2, 3 using statistics magic. Suppose this yields an association score of 0.8.\nNow genotype gene 4‚Äôs association with the trait is calculated from all of the other genotypes, which include 1, 2, 3 and comes up with an association score of 0.8. But this test included the genotypes 1, 2, 3, and many others with those genes. We adjust for them with the earlier 0.8, since we have their association with the trait. This shows us that 4 actually does not correlate with the trait.\nWhen we do the same thing the other way around, genotype 1, 2, 4 would give 0.2, and genotype 1, 2, 3, 4 would give 0.80, and adjusted for the effects of genotype 1, 2, 4, 3 would give still give 0.6. This shows that 3 is actually related.\nThere is a problem when both contribute significantly, e.g. 3, and 4, 0.8, and 0.8. This is not handled by Regenie.\nStatistics Magic\nThis is the calculation of the polygenic risk score."},"yggdrasil/Sea-Born's-Data-Visualisation-Code":{"slug":"yggdrasil/Sea-Born's-Data-Visualisation-Code","filePath":"yggdrasil/Sea Born's Data Visualisation Code.md","title":"Sea Born's Data Visualisation Code","links":[],"tags":[],"content":"To import sea born, use\nimport seaborn \n \nTo plot a histogram, use\nseaborn.histplot(data = data, x=&quot;Name of Column with numerical value&quot;, hue=&quot;Name of y axis variable&quot;, binwidth = 2, multiple=&quot;stack&quot;) \nseaborn.histplot() takes data as a pandas table, and subsequent arguments are the column names. x is a column name, and the hue is also a column name. binwidth is self explaining and multiple=&quot;stack&quot; is an optional argument showing that the data parts need to be stacked.\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n# Plot the histogram\nsns.histplot(data=data, x=&quot;Name of Column with numerical value&quot;, hue=&quot;Name of y axis variable&quot;, binwidth=2, multiple=&quot;stack&quot;)\n \n# Mean line\nmean_value = data[&quot;Name of Column with numerical value&quot;].mean()\nplt.axvline(mean_value, color=&#039;red&#039;, linestyle=&#039;dashed&#039;, linewidth=2, label=f&#039;Mean: {mean_value:.2f}&#039;)\n \n# Move legend outside to the right\nplt.legend(loc=&#039;upper left&#039;, bbox_to_anchor=(1, 1))\n \n# Adjust layout so the legend isn&#039;t cut off\nplt.tight_layout()\n \n# Show plot\nplt.show()\n "},"yggdrasil/VCF-(Complete)":{"slug":"yggdrasil/VCF-(Complete)","filePath":"yggdrasil/VCF (Complete).md","title":"VCF (Complete)","links":["yggdrasil/PLINK-(Complete)"],"tags":[],"content":"üß¨ What is a VCF File?\nVCF stands for Variant Call Format. It‚Äôs a standard text file format used in bioinformatics to store genetic variant data‚Äîlike SNPs (single nucleotide polymorphisms), insertions, deletions, and structural variants‚Äîdetected from sequencing data.\n\nüì¶ VCF File Structure\nA typical VCF file has two main sections:\n\n\nHeader (starts with ## or #)\n\n\nData Records (tab-delimited columns)\n\n\n\n1. üìù Header\n\n\nStarts with multiple ## metadata lines (e.g. info about reference genome, filters, formats).\n\n\nThe final header line begins with #CHROM and defines the column names.\n\n\nExample:\n##fileformat=VCFv4.2\n##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&gt;\n##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&gt;\n#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT Sample1 Sample2\n\n2. üî¢ Data Rows\nEach line is a variant record with at least these columns:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColumnMeaningCHROMChromosomePOSPosition on the chromosomeIDVariant ID (e.g., dbSNP rsID)REFReference alleleALTAlternate allele(s)QUALQuality score of the variantFILTERFilter status (e.g., PASS)INFOKey-value pairs with extra detailsFORMATHow to interpret sample columnsSample(s)Genotype data per individual\nExample:\nchr1  1234567  rs123456  G  A  50  PASS  DP=100  GT  0/1  1/1\n\nüîç INFO and FORMAT Fields\nThese are semicolon- or colon-delimited fields holding detailed info:\n\n\nINFO=DP=100: Depth of reads\n\n\nFORMAT=GT:AD: Genotype, Allelic Depth\n\n\nSample1=0/1:35,65: Heterozygous with 35 REF reads and 65 ALT reads\n\n\n\nüìÅ File Extensions\n\n\n.vcf: plain text\n\n\n.vcf.gz: compressed version (bgzip + tabix index)\n\n\n\nüõ† Tools That Use VCFs\n\n\nbcftools, vcftools ‚Äì for manipulating VCFs\n\n\nPLINK (Complete), GATK, SAMtools ‚Äì common in pipelines\n\n\nANNOVAR, VEP ‚Äì for annotating variants\n\n\n"},"yggdrasil/What-is-Mendelian-Randomisation":{"slug":"yggdrasil/What-is-Mendelian-Randomisation","filePath":"yggdrasil/What is Mendelian Randomisation.md","title":"What is Mendelian Randomisation","links":[],"tags":[],"content":"\n\n                  \n                  Video\n                  \n                \n\n\nThis video does a really good job explaining it.\nyoutu.be/LoTgfGotaQ4\n\n\n\n\n"},"yggdrasil/bed-file-format":{"slug":"yggdrasil/bed-file-format","filePath":"yggdrasil/bed file format.md","title":"bed file format","links":["yggdrasil/Download-PLINK-2"],"tags":[],"content":"The .bed format is a binary file format that can be generated using Plink2. It can also be generated from plink1.9, though this is not something that you have tried before.\nDownload PLINK 2 should help you with generating a .bed from .bgen using PLINK2."},"yggdrasil/polygenic-risk-score":{"slug":"yggdrasil/polygenic-risk-score","filePath":"yggdrasil/polygenic risk score.md","title":"polygenic risk score","links":[],"tags":[],"content":"TLDR?\nA polygenic risk score (PRS) is a way to estimate an individual‚Äôs genetic predisposition to a certain trait or disease by combining the effects of many genetic variants across the genome.\n\nüî¨ What Is It?\nA PRS summarizes the cumulative effect of many single-nucleotide polymorphisms (SNPs), each of which contributes a small amount to the risk of a complex trait (like heart disease, diabetes, height, or intelligence).\n\nüßÆ How Is It Calculated?\nAt a high level, the formula looks like this:\nPRS=‚àëi=1nŒ≤i‚ãÖGi\\text{PRS} = \\sum_{i=1}^{n} \\beta_i \\cdot G_i\nWhere:\n\n\nŒ≤i\\beta_i: Effect size (log-odds or regression coefficient) of SNP ii, typically from a GWAS summary statistics file\n\n\nGiG_i: The individual‚Äôs genotype at SNP ii, usually encoded as 0, 1, or 2 copies of the risk allele\n\n\nnn: Number of SNPs included in the score (often filtered by p-value, LD pruning, etc.)\n\n\n\nüõ†Ô∏è Steps to Calculate PRS\n\n\nGet GWAS Summary Statistics\nFrom a large, high-quality genome-wide association study (GWAS), download effect sizes (usually beta or odds ratio), p-values, and SNP IDs.\n\n\nQuality Control &amp; Filtering\n\n\nRemove ambiguous SNPs (e.g., A/T or C/G)\n\n\nApply p-value threshold (e.g., p&lt;1e‚àí5p &lt; 1e-5) or use all SNPs\n\n\nPerform LD pruning to reduce correlation between nearby SNPs\n\n\n\n\nMatch SNPs to Genotype Data\n\nMake sure the SNPs in the GWAS summary stats match those in your individual-level genotype dataset (e.g., PLINK .bed/.bim/.fam files)\n\n\n\nCalculate the Weighted Sum\n\n\nFor each SNP: multiply the number of risk alleles (0, 1, 2) by the GWAS effect size\n\n\nSum over all selected SNPs to get the individual‚Äôs raw PRS\n\n\n\n\nStandardize the Score (optional)\n\n\nYou can z-score normalize across individuals in the cohort:\nzPRSi=PRSi‚àíŒºœÉ\\text{zPRS}_i = \\frac{\\text{PRS}_i - \\mu}{\\sigma}\nwhere Œº\\mu and œÉ\\sigma are the mean and standard deviation across individuals\n\n\n\n\n\nüß† Example\nSay we use 3 SNPs:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSNPEffect Size (Œ≤)Genotype (G)rs10.122rs2-0.081rs30.200\nThen:\nPRS=(0.12√ó2)+(‚àí0.08√ó1)+(0.20√ó0)=0.24‚àí0.08+0=0.16\\text{PRS} = (0.12 \\times 2) + (-0.08 \\times 1) + (0.20 \\times 0) = 0.24 - 0.08 + 0 = 0.16\n\nüß∞ Common Tools\n\n\nPLINK: Widely used for genotype handling and PRS calculation\n\n\nPRSice: Automates PRS calculation and clumping\n\n\nLDpred: Bayesian method that adjusts effect sizes for LD\n\n\nscikit-learn or R for custom pipelines and machine learning on PRS\n\n\n\n‚ö†Ô∏è Notes &amp; Limitations\n\n\nPRS performance depends heavily on the ancestry match between your target individual and the GWAS cohort.\n\n\nEnvironmental and lifestyle factors aren‚Äôt captured.\n\n\nSome diseases are oligogenic or monogenic, not suitable for PRS.\n\n\n"}}